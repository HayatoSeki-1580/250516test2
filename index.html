<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>社内学習ブラウザ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Ensure Inter font is loaded, Tailwind uses it by default */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom styles */
        /* Style for options */
        .option-label {
            display: block;
            margin-bottom: 0.75rem; /* mb-3 */
            padding: 0.75rem; /* p-3 */
            border: 1px solid #d1d5db; /* border border-gray-300 */
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: #ffffff; /* bg-white */
        }

        /* Allow pointer cursor only when not answered */
        #options-container:not(.answered) .option-label {
             cursor: pointer;
        }

        #options-container:not(.answered) .option-label:hover {
            background-color: #f3f4f6; /* hover:bg-gray-100 */
            border-color: #9ca3af; /* hover:border-gray-400 */
        }

        /* Style for selected option (before checking) */
        #options-container:not(.answered) .option-label input[type="radio"]:checked + .option-text-span {
             font-weight: 500; /* font-medium */
             color: #1e40af; /* text-blue-800 */
        }

         /* Style for selected option (before checking) - parent label style */
        #options-container:not(.answered) .option-label input[type="radio"]:checked + .option-text-span::before {
            content: '▶ '; /* Add a marker for selected, optional */
            color: #2563eb; /* blue-600 */
        }



        /* Style for correct answer */
        .option-label.correct-answer {
            background-color: #d4edda; /* bg-green-100 */
            border-color: #4ade80; /* border-green-400 */
            font-weight: bold;
        }

        /* Style for incorrect answer selected by user */
        .option-label.incorrect-answer {
            background-color: #f8d7da; /* bg-red-100 */
            border-color: #f87171; /* border-red-400 */
             /* Optional: add strikethrough or other visual cue */
        }

        /* Style for non-selected options after answer */
        #options-container.answered .option-label:not(.correct-answer):not(.incorrect-answer) {
            opacity: 0.6; /* Dim other options */
        }

        /* Hide default radio button */
        .option-label input[type="radio"] {
            display: none;
        }

        /* Style for result message */
        .result {
            margin-top: 1.25rem; /* mt-5 */
            padding: 0.75rem; /* p-3 */
            border-radius: 0.375rem; /* rounded-md */
            font-weight: bold;
            min-height: 1.5em;
        }

        .result.correct {
            background-color: #d4edda; /* bg-green-100 */
            color: #14532d; /* text-green-800 */
             border: 1px solid #c3e6cb; /* border-green-200 */
        }

        .result.incorrect {
            background-color: #f8d7da; /* bg-red-100 */
            color: #7f1d1d; /* text-red-800 */
            border: 1px solid #f5c6cb; /* border-red-200 */
        }

        /* Style for incorrect list items */
        #incorrect-list li {
             background-color: #fcf2f2; /* Light red background */
             border: 1px solid #ebcccc; /* Red border */
             border-radius: 0.25rem; /* Tailwind rounded-md */
             padding: 0.75rem; /* Tailwind p-3 */
             margin-bottom: 0.5rem; /* Tailwind mb-2 */
             cursor: pointer;
             transition: background-color 0.2s ease;
        }
        #incorrect-list li:hover {
            background-color: #f8d7da; /* Tailwind equivalent of bg-red-100 */
        }
        #incorrect-list li strong {
             color: #a94442; /* Darker red text */
        }

        /* Progress bar styles */
        #progress-bar-container {
            width: 100%;
            background-color: #e5e7eb; /* bg-gray-200 */
            border-radius: 9999px; /* rounded-full */
            height: 8px; /* h-2 */
            margin-bottom: 1.5rem; /* mb-6 */
            overflow: hidden; /* ensure the bar stays within the container */
        }

        #progress-bar {
            height: 100%;
            width: 0%; /* Initial width */
            background-color: #3b82f6; /* bg-blue-500 */
            border-radius: 9999px; /* rounded-full */
            transition: width 0.5s ease-in-out;
        }

        /* Styles for formatted question items */
        .question-items-container {
            margin-top: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #d1d5db; /* Add border around the whole table-like structure */
            border-radius: 0.375rem; /* Rounded corners */
            overflow: hidden; /* Ensures borders within are contained */
        }

        .question-item, .question-items-header {
            display: grid;
            /* Define columns for empty space, label, quantity, unit */
            grid-template-columns: 2rem 2rem 12rem 1fr; /* Added column for empty space */
            gap: 0.5rem; /* Gap between columns */
            padding: 0.75rem; /* Padding within each row */
            border-bottom: 1px solid #e5e7eb; /* Border between rows */
            align-items: center; /* Vertically align content */
        }

        .question-item:last-child {
            border-bottom: none; /* No border after the last row */
        }

        .question-item .item-label {
            font-weight: bold;
             grid-column: 2 / 3; /* Position item label in the second column */
        }

         .question-item .item-quantity {
             grid-column: 3 / 4; /* Position item quantity in the third column */
         }

         .question-item .item-unit {
             grid-column: 4 / 5; /* Position item unit in the fourth column */
         }


        .question-items-header {
            font-weight: bold;
            background-color: #f9fafb; /* Light background for header */
            border-bottom: 1px solid #d1d5db; /* Border below header */
            /* Position header text in the correct columns */
             grid-template-columns: 2rem 2rem 12rem 1fr; /* Match columns with items */
        }

         .question-items-header .header-quantity {
             grid-column: 3 / 4; /* Position quantity header in the third column */
         }

         .question-items-header .header-unit {
             grid-column: 4 / 5; /* Position unit header in the fourth column */
         }


         /* Adjust column widths for smaller screens if necessary */
        @media (max-width: 600px) {
            .question-item, .question-items-header {
                 grid-template-columns: 1.5rem 1.5rem 8rem 1fr; /* Adjust column widths for smaller screens */
                 gap: 0.3rem;
                 padding: 0.5rem;
            }
             .question-item .item-quantity {
                 grid-column: 3 / 4;
             }
             .question-item .item-unit {
                 grid-column: 4 / 5;
             }
             .question-items-header .header-quantity {
                 grid-column: 3 / 4;
             }
             .question-items-header .header-unit {
                 grid-column: 4 / 5;
             }
        }

        /* Styles for mode selection and year list */
        #mode-selection-container, #year-list-container, #question-list-container {
            display: none; /* Initially hidden */
            text-align: center;
        }

        .mode-button, .year-button, .question-list-item {
            display: block;
            width: 100%;
            padding: 1rem;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            font-weight: 600;
            color: #ffffff;
            background-color: #3b82f6; /* blue-500 */
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
            text-align: center;
        }

        .mode-button:hover, .year-button:hover, .question-list-item:hover {
            background-color: #2563eb; /* blue-600 */
        }

        .year-button {
            background-color: #10b981; /* green-500 */
        }

        .year-button:hover {
            background-color: #059669; /* green-600 */
        }

         .question-list-item {
             background-color: #60a5fa; /* blue-400 */
             font-size: 1rem;
             text-align: left;
         }

         .question-list-item:hover {
             background-color: #3b82f6; /* blue-500 */
         }

        #question-list-container h3 {
            font-size: 1.5rem;
            color: #1e40af; /* blue-800 */
            margin-bottom: 1.5rem;
        }

         .back-button {
             margin-top: 1.5rem;
             padding: 0.75rem 1.5rem;
             font-size: 1rem;
             font-weight: 600;
             color: #ffffff;
             background-color: #6b7280; /* gray-500 */
             border-radius: 0.375rem;
             cursor: pointer;
             transition: background-color 0.3s ease;
         }

         .back-button:hover {
             background-color: #4b5563; /* gray-600 */
         }

    </style>
</head>
<body class="bg-gray-100 flex justify-center items-start min-h-screen py-8 px-4">

    <div id="quiz-container" class="bg-white p-8 rounded-lg shadow-xl max-w-xl w-full">

        <div id="mode-selection-container">
            <h2 class="text-2xl text-blue-700 mb-6">学習モード選択</h2>
            <button id="random-mode-button" class="mode-button">ランダム出題開始 (5問)</button>
            <button id="year-select-mode-button" class="mode-button">年度を選択して学習</button>
        </div>

        <div id="year-list-container">
            <h2 class="text-2xl text-blue-700 mb-6">年度選択</h2>
            <div id="year-buttons-container">
                </div>
            <button id="back-to-mode-select-button" class="back-button">モード選択に戻る</button>
        </div>

        <div id="question-list-container">
            <h3 id="selected-year-title"></h3>
            <div id="questions-for-year-container">
                </div>
            <button id="back-to-year-select-button" class="back-button">年度選択に戻る</button>
        </div>

        <div id="question-container">
            <div id="progress-bar-container">
                <div id="progress-bar"></div>
            </div>
            <h2 id="question-title" class="text-xl md:text-2xl text-blue-700 mb-4 pb-2 border-b-2 border-blue-700"></h2>
            <div id="question-text" class="mb-6 whitespace-pre-wrap text-gray-800"></div>
            <div id="options-container">
                </div>
            <div id="result" class="result"></div>
            <button id="next-button" class="mt-6 px-6 py-3 text-lg font-semibold text-white bg-green-600 hover:bg-green-700 rounded-md cursor-pointer transition-colors duration-300 w-full md:w-auto" style="display: none;">次の問題へ</button>
            <button id="back-to-list-button" class="mt-6 px-6 py-3 text-lg font-semibold text-white bg-gray-600 hover:bg-gray-700 rounded-md cursor-pointer transition-colors duration-300 w-full md:w-auto" style="display: none;">問題一覧に戻る</button>
        </div>

        <div id="quiz-end-message" class="mt-8 text-center" style="display: none;">
            <h2 class="text-2xl text-blue-700 mb-4">クイズ終了！</h2>
            <p id="final-score" class="text-xl mb-5 font-semibold"></p>
             <div id="incorrect-list-container" class="mt-8 text-left border-t pt-5">
                </div>
            <button id="reset-button" class="mt-6 px-6 py-3 text-lg font-semibold text-gray-800 bg-yellow-400 hover:bg-yellow-500 rounded-md cursor-pointer transition-colors duration-300 w-full md:w-auto">もう一度挑戦する</button>
        </div>
    </div>

    <script>
        // JSONデータをJavaScript変数として直接埋め込みます
        const allQuizData = [
            {
                "問題番号": "問1",
                "年度": "第59回(平成21年)",
                "問題文": "次の記述は、計量法第1条の目的に関するものであるが、(ア)~(ウ)に入る語句の組合せとして正しいものを一つ選べ。\nこの法律は、計量の(ア)を定め、適正な(イ)を確保し、もって(ウ)に寄与することを目的とする。",
                "選択肢": [
                    "(ア)標準\n(イ)計量の実施\n(ウ)社会経済の発展及び生活水準の向上",
                    "(ア)基準\n(イ)計量の実施\n(ウ)経済の発展及び文化の向上",
                    "(ア)基準\n(イ)計量器の校正\n(ウ)社会経済の発展及び生活水準の向上",
                    "(ア)基準\n(イ)計量器の供給\n(ウ)経済の発展及び文化の向上",
                    "(ア)標準\n(イ)計量器の供給\n(ウ)社会経済の発展及び生活水準の向上"
                ],
                "正解": "2"
            },
            {
                "問題番号": "問2",
                "年度": "第59回(平成21年)",
                "問題文": "計量法の用語の定義に関する次のア~オの記述のうち、誤っているものの組合せを次の1~5の中から一つ選べ。\nア この法律において「取引」とは、公に又は業務上他人に一定の事実が真実で\nある旨を表明することをいう。\n\nイ この法律において「計量単位」とは、計量の基準となるものをいう。\nウ この法律で定める「物象の状態の量」には、速さは含まれない。\nエ この法律において「特定計量器」とは、取引若しくは証明における計量に使用され、又は主として一般消費者の生活の用に供されるすべての計量器をいう。\nオ この法律において「標準物質」とは、政令で定める物象の状態の量の特定の値が付された物質であって、当該物象の状態の量の計量をするための計量器の誤差の測定に用いるものをいう。",
                "選択肢": [
                    "ア、イ、エ、オ",
                    "ア、ウ、工",
                    " ア、ウ、オ",
                    " イ、エ、オ",
                    " イ、ウ、工"
                ],
                "正解": "2"
            },
            // ... (他の問題データは省略されていますが、実際にはここに全ての問題データが含まれます) ...
            {
                "問題番号": "問25",
                "年度": "第59回(平成21年)",
                "問題文": "取引又は証明における法定計量単位による計量に計量器でないものを使用したことにより、計量法第16条第1項の規定に違反した者に適用される計量法における罰則等として正しいものを、次の中から一つ選べ。",
                "選択肢": [
                    "6月以下の懲役若しくは50万円以下の罰金に処せられ、又はこれを併科される。",
                    "30万円以下の過料に処せられる。",
                    "1万円未満の科料に処せられる。",
                    "経済産業大臣によって業務停止を命令される。",
                    "計量法には当該者に対する罰則規定はなく、刑法の規定による処罰を受ける。"
                ],
                "正解": "1"
            }
        ];

        let questions = []; // 現在表示する問題の配列
        const numberOfQuestionsToAsk = 5; // ランダム出題時の問題数
        let currentQuestionIndex = -1; // 現在の問題のインデックス (0から始まります)
        let correctAnswers = 0; // 正答数
        let answered = false; // 回答済みフラグ
        let incorrectQuestions = []; // 間違えた問題を格納する配列 (問題オブジェクトを格納)
        let currentMode = 'select'; // 'select', 'random', 'year_select', 'question_list', 'quiz', 'end'

        // DOM要素の取得
        const quizContainer = document.getElementById('quiz-container');
        const modeSelectionContainer = document.getElementById('mode-selection-container');
        const yearListContainer = document.getElementById('year-list-container');
        const questionListContainer = document.getElementById('question-list-container');
        const questionContainer = document.getElementById('question-container');
        const questionTitle = document.getElementById('question-title');
        const questionTextDiv = document.getElementById('question-text'); // div要素を取得
        const optionsContainer = document.getElementById('options-container');
        const resultDiv = document.getElementById('result');
        const nextButton = document.getElementById('next-button');
        const backToListButton = document.getElementById('back-to-list-button');
        const quizEndMessage = document.getElementById('quiz-end-message');
        const finalScore = document.getElementById('final-score');
        const resetButton = document.getElementById('reset-button');
        const incorrectListContainer = document.getElementById('incorrect-list-container'); // 間違えた問題一覧表示用コンテナ
        const progressBar = document.getElementById('progress-bar'); // プログレスバー
        const randomModeButton = document.getElementById('random-mode-button');
        const yearSelectModeButton = document.getElementById('year-select-mode-button');
        const yearButtonsContainer = document.getElementById('year-buttons-container');
        const backToModeSelectButton = document.getElementById('back-to-mode-select-button');
        const selectedYearTitle = document.getElementById('selected-year-title');
        const questionsForYearContainer = document.getElementById('questions-for-year-container');
        const backToYearSelectButton = document.getElementById('back-to-year-select-button');


        // ボタンにイベントリスナーを設定
        if (randomModeButton) randomModeButton.addEventListener('click', startRandomQuiz);
        if (yearSelectModeButton) yearSelectModeButton.addEventListener('click', showYearSelection);
        if (nextButton) nextButton.addEventListener('click', loadNextQuestion);
        if (resetButton) resetButton.addEventListener('click', resetQuiz);
        if (backToListButton) backToListButton.addEventListener('click', returnToIncorrectList);
        if (backToModeSelectButton) backToModeSelectButton.addEventListener('click', showModeSelection);
        if (backToYearSelectButton) backToYearSelectButton.addEventListener('click', showYearSelection);


        // 画面表示を切り替える関数
        function showScreen(screenName) {
            if (modeSelectionContainer) modeSelectionContainer.style.display = 'none';
            if (yearListContainer) yearListContainer.style.display = 'none';
            if (questionListContainer) questionListContainer.style.display = 'none';
            if (questionContainer) questionContainer.style.display = 'none';
            if (quizEndMessage) quizEndMessage.style.display = 'none';

            if (screenName === 'select' && modeSelectionContainer) {
                modeSelectionContainer.style.display = 'block';
            } else if (screenName === 'year_select' && yearListContainer) {
                yearListContainer.style.display = 'block';
            } else if (screenName === 'question_list' && questionListContainer) {
                questionListContainer.style.display = 'block';
            } else if (screenName === 'quiz' && questionContainer) {
                questionContainer.style.display = 'block';
            } else if (screenName === 'end' && quizEndMessage) {
                quizEndMessage.style.display = 'block';
            }
             // プログレスバーの表示/非表示はクイズ画面でのみ制御
             // currentMode の値に基づいてプログレスバーの表示を制御
            if (progressBar && progressBar.parentElement) {
                progressBar.parentElement.style.display = (screenName === 'quiz' && currentMode === 'random') ? 'block' : 'none';
            }
        }

        // 初期画面表示
        document.addEventListener('DOMContentLoaded', (event) => {
            showScreen('select');
        });


        // 配列をシャッフルする関数 (Fisher-Yates (Knuth) Shuffle)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // 要素を交換
            }
            return array;
        }

        // ランダム出題モード開始
        function startRandomQuiz() {
            if (allQuizData.length > 0) {
                currentMode = 'random';
                // クイズデータをリセット（以前の解答情報をクリア）
                allQuizData.forEach(q => {
                    delete q.userChoice;
                    delete q.isCorrect;
                });
                questions = shuffleArray([...allQuizData]).slice(0, numberOfQuestionsToAsk);
                correctAnswers = 0;
                currentQuestionIndex = -1;
                incorrectQuestions = [];
                answered = false;
                if (optionsContainer) optionsContainer.classList.remove('answered');
                loadNextQuestion();
                showScreen('quiz');
            } else {
                console.error('問題データが見つかりません。');
                if (resultDiv) {
                     resultDiv.textContent = `問題データがありません。`;
                     resultDiv.className = 'result incorrect';
                }
                currentMode = 'end';
                showScreen('end');
                if (finalScore) finalScore.textContent = 'クイズを開始できませんでした。';
                if (resetButton) resetButton.style.display = 'block';
            }
        }

        // 年度選択画面表示
        function showYearSelection() {
            if (!yearButtonsContainer) return;
            currentMode = 'year_select';
             // 年度選択時には解答情報をクリアする（年度ごとに新しく始めるため）
            allQuizData.forEach(q => {
                delete q.userChoice;
                delete q.isCorrect;
            });

            yearButtonsContainer.innerHTML = '';
            const years = [...new Set(allQuizData.map(q => q.年度))].sort();

            years.forEach(year => {
                const button = document.createElement('button');
                button.className = 'year-button';
                button.textContent = year;
                button.addEventListener('click', () => showQuestionList(year));
                yearButtonsContainer.appendChild(button);
            });

            showScreen('year_select');
        }

        // 年度ごとの問題一覧表示
        function showQuestionList(year) {
            if (!questionsForYearContainer || !selectedYearTitle) return;
            currentMode = 'question_list';

            questionsForYearContainer.innerHTML = '';
            selectedYearTitle.textContent = `${year} の問題一覧`;

            questions = allQuizData.filter(q => q.年度 === year);
             // 問題一覧表示時にも、その年度の問題の解答情報をクリアしておく（再挑戦の場合を考慮）
            questions.forEach(q => {
                delete q.userChoice;
                delete q.isCorrect;
            });


            if (questions.length > 0) {
                questions.forEach((question, index) => {
                    const listItem = document.createElement('div');
                    listItem.className = 'question-list-item';
                    listItem.innerHTML = `<strong>${question.問題番号}</strong>: ${question.問題文 ? question.問題文.substring(0, 50) + '...' : (question.問題項目 ? '物象の状態の量と法定計量単位の組み合わせ' : '問題文なし')}`;
                    listItem.addEventListener('click', () => startYearQuiz(index));
                    questionsForYearContainer.appendChild(listItem);
                });
            } else {
                const message = document.createElement('p');
                message.textContent = 'この年度の問題は見つかりませんでした。';
                questionsForYearContainer.appendChild(message);
            }

            showScreen('question_list');
        }

        // 年度選択モードでのクイズ開始
        function startYearQuiz(questionIndex) {
             if (questions.length > 0 && questionIndex >= 0 && questionIndex < questions.length) {
                currentMode = 'quiz'; // 年度別クイズは 'quiz' モード
                // correctAnswers = 0; // 年度別では問題ごとの正誤のみ記録
                currentQuestionIndex = questionIndex; // 選択された問題のインデックスを設定
                // incorrectQuestions = []; // 年度別では間違えた問題リストは使用しないか、別途管理
                answered = false;
                if (optionsContainer) optionsContainer.classList.remove('answered');
                loadSpecificQuestion(questions[currentQuestionIndex]); // 選択された問題をロード
                showScreen('quiz');
                if (progressBar && progressBar.parentElement) progressBar.parentElement.style.display = 'none';
             } else {
                 console.error("指定された問題インデックスが無効です。", questionIndex);
             }
        }



        // 特定の問題をロードする関数 (間違えた問題リストからの遷移用と年度別学習用)
        function loadSpecificQuestion(question) {
            if (!questionContainer || !quizEndMessage || !resultDiv || !nextButton || !backToListButton || !incorrectListContainer || !resetButton || !questionTitle || !questionTextDiv || !optionsContainer) return;

            const currentQuestion = question; // 指定された問題オブジェクト

            // currentQuestionIndex を、渡された question オブジェクトが `questions` 配列の何番目か、に基づいて設定する。
            // これは、handleOptionSelect がグローバルの currentQuestionIndex を参照するため。
            // ただし、間違えた問題リストから来た場合、`questions` 配列はランダムクイズの時のもの。
            // 年度別クイズから来た場合は、その年度の `questions` 配列。
            // `loadSpecificQuestion` が呼ばれる文脈によって `questions` の内容が異なるため、
            // `question` オブジェクトが現在の `questions` 配列内に存在するか確認する。
            let foundIndex = -1;
            if (Array.isArray(questions)) {
                 foundIndex = questions.findIndex(q => q.問題番号 === currentQuestion.問題番号 && q.年度 === currentQuestion.年度);
            }

            if (foundIndex !== -1) {
                currentQuestionIndex = foundIndex;
            } else {
                // `questions` 配列に存在しない場合（例: 間違えた問題リストから直接来た場合で、`questions` がクリアされているなど）
                // この場合、`currentQuestionIndex` はグローバルな意味を持たなくなるので注意。
                // `handleOptionSelect` が正しく動作するためには、`questions[currentQuestionIndex]` が `currentQuestion` と一致する必要がある。
                // 一時的に `questions` を現在の問題のみの配列にするか、`handleOptionSelect` を修正する必要がある。
                // ここでは、間違えた問題レビュー時は `currentQuestionIndex` を 0 とし、`questions` を一時的に現在の問題のみの配列とする。
                if (currentMode === 'end') { // 間違えた問題レビュー時
                    questions = [currentQuestion];
                    currentQuestionIndex = 0;
                } else {
                    // それ以外のケース（年度別など）では、呼び出し元で currentQuestionIndex が設定されている前提
                    // もし未設定ならエラーログ
                    if (currentQuestionIndex === -1 || !questions[currentQuestionIndex] || questions[currentQuestionIndex].問題番号 !== currentQuestion.問題番号) {
                        console.warn("loadSpecificQuestion: currentQuestionIndex may not be correctly set for the provided question.");
                    }
                }
            }


            // answered = false; // ★修正: ここでは answered の状態をリセットしない。解答済みならその状態を維持する。
            optionsContainer.innerHTML = ''; // オプションコンテナをクリア
            optionsContainer.classList.remove('answered'); // まずクラスを削除

            resultDiv.textContent = '';
            resultDiv.className = 'result';
            nextButton.style.display = 'none';
            resetButton.style.display = 'none';
            // incorrectListContainer.innerHTML = ''; // レビュー画面ではこれはクリアしない

            if (currentMode === 'quiz' || currentMode === 'end') { // 年度別学習中 or 間違えた問題レビュー中
                 backToListButton.style.display = 'inline-block';
            } else {
                 backToListButton.style.display = 'none';
            }

            questionTitle.textContent = `${currentQuestion.年度} ${currentQuestion.問題番号}`;
            if (currentMode === 'quiz' && questions.length > 1 && foundIndex !== -1) { // 年度別クイズで複数問題ある場合
                 questionTitle.textContent = `(${foundIndex + 1} / ${questions.length}) ${currentQuestion.年度} ${currentQuestion.問題番号}`;
            }


            if (currentQuestion.問題項目) {
                let itemsHtml = '<div class="question-items-container">';
                 if (currentQuestion.問題文_original) {
                     itemsHtml += `<p>${currentQuestion.問題文_original.replace(/\n/g, '<br>')}</p><br>`;
                 }
                 itemsHtml += '<div class="question-items-header"><span></span> <span class="header-quantity">物象の状態の量</span> <span class="header-unit">法定計量単位</span></div>';
                currentQuestion.問題項目.forEach(item => {
                    itemsHtml += `<div class="question-item"><span class="item-label">${item.項目}</span> <span class="item-quantity">${item.物象の状態の量}</span> <span class="item-unit">${item.法定計量単位}</span></div>`;
                });
                itemsHtml += '</div>';
                questionTextDiv.innerHTML = itemsHtml;
            } else if (currentQuestion.問題文) {
                questionTextDiv.innerHTML = currentQuestion.問題文.replace(/\n/g, '<br>');
            } else {
                 questionTextDiv.textContent = '問題文の形式が不明です。';
            }


            if (currentQuestion.選択肢) {
                currentQuestion.選択肢.forEach((optionText, index) => {
                    const label = document.createElement('label');
                    label.className = 'option-label';
                    const input = document.createElement('input');
                    input.type = 'radio';
                    input.name = 'answer';
                    input.value = (index + 1).toString();

                    const span = document.createElement('span');
                     span.className = 'option-text-span';
                    span.textContent = `${index + 1}. ${optionText}`;

                    label.appendChild(input);
                    label.appendChild(span);
                    optionsContainer.appendChild(label);

                    // ★修正: 間違えた問題レビュー時、または年度別で解答済みの場合の処理
                    if (currentQuestion.hasOwnProperty('userChoice')) { // 解答履歴がある場合
                        input.disabled = true; // ラジオボタンを無効化
                        if (input.value === currentQuestion.userChoice) {
                            input.checked = true; // ユーザーが選んだ選択肢をチェック状態にする
                        }
                    } else {
                        // 通常のクイズ（未解答）の場合
                        input.addEventListener('change', handleOptionSelect);
                    }
                });
            }

            // ★修正: 解答履歴に基づいてスタイルと結果を復元
            if (currentQuestion.hasOwnProperty('userChoice')) {
                answered = true; // 解答済み状態にする
                optionsContainer.classList.add('answered'); // answeredクラスを追加
                const correctAnswerValue = currentQuestion.正解;
                const userChoiceValue = currentQuestion.userChoice;

                optionsContainer.querySelectorAll('.option-label').forEach(label => {
                    const radio = label.querySelector('input[type="radio"]');
                    if (radio) {
                        if (radio.value === correctAnswerValue) {
                            label.classList.add('correct-answer');
                        }
                        if (radio.value === userChoiceValue && userChoiceValue !== correctAnswerValue) {
                            label.classList.add('incorrect-answer');
                        }
                    }
                });

                if (currentQuestion.isCorrect) {
                    resultDiv.textContent = '正解です！';
                    resultDiv.className = 'result correct';
                } else {
                    resultDiv.textContent = `不正解です。正解は ${correctAnswerValue} です。`;
                    resultDiv.className = 'result incorrect';
                }
            } else {
                // まだ解答していない場合 (年度別クイズの初回表示など)
                answered = false;
                optionsContainer.classList.remove('answered');
            }
             showScreen('quiz');
        }



        // 次の問題をロードする関数 (ランダム出題モード用)
        function loadNextQuestion() {
            if (!questionContainer || !quizEndMessage || !resultDiv || !nextButton || !backToListButton || !incorrectListContainer || !resetButton || !questionTitle || !questionTextDiv || !optionsContainer || !progressBar || !progressBar.parentElement) return;

            answered = false;
             optionsContainer.classList.remove('answered'); // 次の問題に進む前にansweredクラスを削除

            currentQuestionIndex++;

            resultDiv.textContent = '';
            resultDiv.className = 'result';
            nextButton.style.display = 'none';
            nextButton.textContent = '次の問題へ';
            backToListButton.style.display = 'none';
            resetButton.style.display = 'none';

             if (currentMode === 'random') {
                 progressBar.parentElement.style.display = 'block';
                 // プログレスバーの更新は、問題が存在する場合のみ行う
                 if (questions.length > 0 && currentQuestionIndex < questions.length) {
                    const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
                    progressBar.style.width = `${progress}%`;
                 } else if (currentQuestionIndex >= questions.length) { // 全問解答後の場合
                    progressBar.style.width = `100%`;
                 }
             } else {
                 progressBar.parentElement.style.display = 'none';
             }


            if (currentQuestionIndex < questions.length) {
                showScreen('quiz');
                incorrectListContainer.innerHTML = '';


                const currentQuestion = questions[currentQuestionIndex];
                 // 問題オブジェクトに以前の解答情報があればクリアする（再挑戦などのため）
                delete currentQuestion.userChoice;
                delete currentQuestion.isCorrect;

                questionTitle.textContent = `(${currentQuestionIndex + 1} / ${questions.length}) ${currentQuestion.年度} ${currentQuestion.問題番号}`;

                if (currentQuestion.問題項目) {
                    let itemsHtml = '<div class="question-items-container">';
                     if (currentQuestion.問題文_original) {
                         itemsHtml += `<p>${currentQuestion.問題文_original.replace(/\n/g, '<br>')}</p><br>`;
                     }
                     itemsHtml += '<div class="question-items-header"><span></span> <span class="header-quantity">物象の状態の量</span> <span class="header-unit">法定計量単位</span></div>';
                    currentQuestion.問題項目.forEach(item => {
                        itemsHtml += `<div class="question-item"><span class="item-label">${item.項目}</span> <span class="item-quantity">${item.物象の状態の量}</span> <span class="item-unit">${item.法定計量単位}</span></div>`;
                    });
                    itemsHtml += '</div>';
                    questionTextDiv.innerHTML = itemsHtml;
                } else if (currentQuestion.問題文) {
                    questionTextDiv.innerHTML = currentQuestion.問題文.replace(/\n/g, '<br>');
                } else {
                    questionTextDiv.textContent = '問題文の形式が不明です。';
                }


                optionsContainer.innerHTML = '';
                if (currentQuestion.選択肢) {
                     currentQuestion.選択肢.forEach((optionText, index) => {
                         const label = document.createElement('label');
                         label.className = 'option-label';
                         const input = document.createElement('input');
                         input.type = 'radio';
                         input.name = 'answer';
                         input.value = (index + 1).toString();

                         const span = document.createElement('span');
                          span.className = 'option-text-span';
                         span.textContent = `${index + 1}. ${optionText}`;

                         label.appendChild(input);
                         label.appendChild(span);
                         optionsContainer.appendChild(label);
                         input.addEventListener('change', handleOptionSelect);
                     });
                 }


            } else { // 全ての問題を解き終わった場合
                currentMode = 'end';
                showScreen('end');
                if (finalScore) finalScore.textContent = `正答数: ${correctAnswers} / ${questions.length}`;
                if (resetButton) resetButton.style.display = 'block';
                displayIncorrectQuestions();
            }
        }

        // 選択肢が選択されたときの処理（回答判定）
        function handleOptionSelect(event) {
            if (answered) return; // すでに回答済みの場合は処理しない

             if (!optionsContainer || !resultDiv || !nextButton || !incorrectQuestions || !questions || currentQuestionIndex === -1 || currentQuestionIndex >= questions.length ) {
                 console.error("回答判定に必要な要素または情報が不足しています。 currentQuestionIndex:", currentQuestionIndex, "questions.length:", questions.length);
                 return;
             }

            answered = true; // 回答済みフラグを立てる
             optionsContainer.classList.add('answered'); // 回答済みクラスを追加

            const selectedAnswerInput = event.target;
            const selectedValue = selectedAnswerInput.value;
            const currentQuestion = questions[currentQuestionIndex];
            if (!currentQuestion) {
                console.error("currentQuestion が undefined です。currentQuestionIndex:", currentQuestionIndex);
                return;
            }
            const correctAnswer = currentQuestion.正解;

            // ★解答情報を問題オブジェクトに保存
            currentQuestion.userChoice = selectedValue;
            currentQuestion.isCorrect = (selectedValue === correctAnswer);


            const optionsLabels = optionsContainer.querySelectorAll('.option-label');

            optionsContainer.querySelectorAll('input[type="radio"]').forEach(radio => {
                 radio.disabled = true; // 全てのラジオボタンを無効化
                 const label = radio.parentElement;
                 label.style.cursor = 'default';
                 label.classList.remove('selected');
             });


            if (currentQuestion.isCorrect) {
                resultDiv.textContent = '正解です！';
                resultDiv.className = 'result correct';
                if (currentMode === 'random') { // ランダムモードの場合のみ全体の正答数をカウント
                    correctAnswers++;
                }
            } else {
                resultDiv.textContent = `不正解です。正解は ${correctAnswer} です。`;
                resultDiv.className = 'result incorrect';
                if (currentMode === 'random' && !incorrectQuestions.find(q => q.問題番号 === currentQuestion.問題番号 && q.年度 === currentQuestion.年度)) { // ランダムモードで、まだリストになければ追加
                    incorrectQuestions.push(currentQuestion);
                } else if (currentMode === 'quiz') { // 年度別学習の場合、間違えたらその場でincorrectQuestionsに追加（ただし、このリストは主にランダムモードの終了時に使う想定）
                     // incorrectQuestions.push(currentQuestion); // 必要であれば年度別でも記録
                }
            }

            // 正解・不正解のスタイル適用
            optionsLabels.forEach(label => {
                 const radio = label.querySelector('input[type="radio"]');
                 if (radio) {
                      const optionValue = radio.value;
                      if (optionValue === correctAnswer) {
                          label.classList.add('correct-answer');
                      }
                      // ユーザーが選択した不正解の選択肢にスタイルを適用
                      if (optionValue === selectedValue && selectedValue !== correctAnswer) {
                          label.classList.add('incorrect-answer');
                      }
                 }
             });

            // ボタン表示の制御
            if (currentMode === 'random') {
                if (currentQuestionIndex < questions.length - 1) { // まだ次の問題がある場合
                    nextButton.textContent = '次の問題へ';
                    nextButton.style.display = 'block';
                } else { // ランダムモードの最後の問題の場合
                    nextButton.textContent = '結果を見る';
                    nextButton.style.display = 'block';
                }
            } else if (currentMode === 'quiz') { // 年度別学習モードの場合
                 backToListButton.style.display = 'inline-block'; // 「問題一覧に戻る」を表示
            }
        }


        // 間違えた問題一覧を表示する関数
        function displayIncorrectQuestions() {
            if (!incorrectListContainer || !quizEndMessage || !resetButton) return;

            incorrectListContainer.innerHTML = '';

            if (incorrectQuestions.length > 0) {
                const title = document.createElement('h3');
                title.className = 'text-xl text-red-700 mb-4';
                title.textContent = '間違えた問題';
                incorrectListContainer.appendChild(title);

                const ul = document.createElement('ul');
                ul.id = 'incorrect-list';

                incorrectQuestions.forEach((question, index) => {
                    const li = document.createElement('li');
                     li.innerHTML = `<strong>${question.年度} ${question.問題番号}</strong>`;
                    li.addEventListener('click', () => {
                        // currentMode = 'end'; // 間違えた問題レビューモードであることを示す
                        // loadSpecificQuestion を呼ぶ前に、その問題が属していた元の questions 配列と index を特定する必要がある。
                        // しかし、incorrectQuestions には問題オブジェクトのコピー(または参照)しかないので、
                        // ここでは単純に question オブジェクトを渡す。
                        // loadSpecificQuestion 側で、この question オブジェクトの解答履歴 (userChoice, isCorrect) を見て表示を復元する。
                        loadSpecificQuestion(question);
                    });
                    ul.appendChild(li);
                });

                incorrectListContainer.appendChild(ul);
            } else {
                const message = document.createElement('p');
                message.className = 'text-lg text-green-700';
                message.textContent = '素晴らしい！全問正解です！';
                incorrectListContainer.appendChild(message);
            }
        }

        // 問題一覧に戻る関数
        function returnToIncorrectList() {
             if (!questionContainer || !quizEndMessage || !nextButton || !backToListButton || !resetButton || !progressBar || !progressBar.parentElement || !optionsContainer) return;

            if (currentMode === 'quiz') { // 年度別学習中の問題から問題一覧へ
                const currentYear = questions[0]?.年度; // questions は年度別問題の配列のはず
                if (currentYear) {
                    showQuestionList(currentYear);
                } else {
                    showYearSelection(); // 念のため
                }
            } else if (currentMode === 'end') { // 間違えた問題のレビュー画面から、クイズ終了画面へ戻る
                // currentMode は 'end' のまま
                showScreen('end'); // クイズ終了画面を再表示
                if (finalScore) finalScore.textContent = `正答数: ${correctAnswers} / ${numberOfQuestionsToAsk}`; // ランダムクイズの時の問題数
                if (resetButton) resetButton.style.display = 'block';
                displayIncorrectQuestions(); // 間違えた問題リストを再表示
            } else {
                showModeSelection(); // それ以外はモード選択へ
            }

             nextButton.style.display = 'none';
             backToListButton.style.display = 'none';
             if (progressBar.parentElement) progressBar.parentElement.style.display = 'none';
             optionsContainer.classList.remove('answered');
             resultDiv.textContent = '';
             resultDiv.className = 'result';
        }

        // モード選択画面に戻る関数
        function showModeSelection() {
            currentMode = 'select';
            questions = [];
            currentQuestionIndex = -1;
            correctAnswers = 0;
            incorrectQuestions = [];
            answered = false;
            if (optionsContainer) optionsContainer.classList.remove('answered');
            // 全てのクイズデータの解答履歴をクリア
            allQuizData.forEach(q => {
                delete q.userChoice;
                delete q.isCorrect;
            });

            showScreen('select');
             if (yearButtonsContainer) yearButtonsContainer.innerHTML = '';
             if (questionsForYearContainer) questionsForYearContainer.innerHTML = '';
             if (incorrectListContainer) incorrectListContainer.innerHTML = '';
             if (resultDiv) resultDiv.textContent = '';
             if (finalScore) finalScore.textContent = '';


             if (nextButton) nextButton.style.display = 'none';
             if (backToListButton) backToListButton.style.display = 'none';
             if (resetButton) resetButton.style.display = 'none';
             if (progressBar && progressBar.parentElement) progressBar.parentElement.style.display = 'none';
        }


        function resetQuiz() {
             // クイズ終了画面 (currentMode === 'end') からの「もう一度挑戦する」
             if (currentMode === 'end') {
                 // incorrectQuestions に何か入っていれば、それはランダムクイズの結果の可能性が高い
                 // numberOfQuestionsToAsk と questions.length を比較しても良い
                 if (incorrectQuestions.length > 0 || (questions.length === numberOfQuestionsToAsk && numberOfQuestionsToAsk > 0) ) {
                    startRandomQuiz(); // ランダムクイズを再開
                 } else { // 年度別学習の単一問題表示後などの可能性も考慮し、モード選択へ
                    showModeSelection();
                 }
             } else { // それ以外の画面からのリセットはモード選択へ
                 showModeSelection();
             }
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            // 初期化時に allQuizData から解答情報を削除しておく
            allQuizData.forEach(q => {
                delete q.userChoice;
                delete q.isCorrect;
            });
            showModeSelection();
        });
    </script>

</body>
</html>
